---
title: "Practical 5"
author: "Chris Davis"
date: "October 3, 2016"
output: 
    html_document:
        toc: true
        number_sections: true
---


```{r, eval=FALSE}
install.packages("dplyr")
```

```{r, message=FALSE}
library(ggplot2)
library(dplyr)
```

# Monte Carlo simulation 

## Short reminder of the lecture

$x = f(u,v)$

* $u$ has uncertainty $s_u$
* $v$ has uncertainty $s_v$

* Construct normal distribution fn,u around $u$ with standard deviation $s_u$ 
* Construct normal distribution fn,v around $v$ with standard deviation $s_v$

Take a random value u1 from  fn,u and $v_1$ from fn,v  and calculate $x1 = f(u1, v1)$

Repeat n times

Take average (or median) of all $x_i$ (i = 1, …n) 

## Example from the lecture (page 25, for now; might be slightly different)
(Chris, maybe add some explanation)

assume that the uncertainties for $p$ and $q$ follow normal distributions

* for $p$, $\mu = 2$ and $\delta = 0.5$
* for $q$, $\mu = 5$ and $\delta = 1$

Assume that for your research you want to calculate f, this is made up (better words), example formula

your professors says here's a formula, calculate the uncertainty

$f = \frac{p \cdot q}{p + q}$

```{r}
# take n samples
n <- 1000
# take n samples from normal distributions with different means and standard deviations
p <- rnorm(n, mean = 2, sd = 0.5)
q <- rnorm(n, mean = 5, sd = 1)
# calculate f(u,v)
f <- p*q/(p+q)
f_bar <- mean(f)
sig <- sd(f)
```

## Try on your own:

Give them a different formula  x = f(u,v)

Let them try a monte carlo simulation with different n 

Tasks:
 
* plot the histogram of x
* calculate mean(x) and std(x)

**TODO** just show the results
If there is enough time you could explain, how to do it with a loop for different n and re-create a plot like in lecture pgs 27, 28
**TODO** this is on page 33,34 now, right?

# Working with real data sets

This is not related to the lecture, so I think I leave this to you. 

I attach two practicals that they had last year, where I taught them the basic of working with data frames, subsets, dates and times etc … 

I think it would be good to keep the structure that we had so far:

* Introduce a concept
* walk them through an example 
* let them try an exercise by themselves

The Guerry data file:

**TODO** have the students download this to their own computer, explain right click, etc (copy from Practical 1).  Add link (where don't show url directly)

Read it in: 
```{r}
data1 <- read.csv(file ="https://raw.githubusercontent.com/cbdavis/DASM/master/data/Guerry.csv")
```

**TODO** explain the different columns - 17 observations per region, 1 NA, etc - how factors and numbers are shown differently.  If you don't see quantiles, it's counting factors

**TODO** need to explain logical indexing - also if have values that are NA, by default NA will be included.  With subset, NA is excluded, also with filter and dplyr.  Indexing can be useful either way - sometimes you want to keep the NAs since the other columns may have valid data that you want to use.


Get an idea what is in it:
```{r}
summary(data1)
```

Reminder: reading in a .csv file gives you a data frame

e.g., `length(input1)` gives you the number of variables, not the length of the data

`dim(input1)` shows the number of rows and columns

select subsets from a data frame
	
as mentioned above

and then we can also address by column names

This is a data set from the Guerry R package, so to get an idea about the variables we need to install the package:
```{r, eval=FALSE}
install.packages("Guerry")
```

Load the library:
```{r}
library(Guerry)
```

and then bring up the help information that relates to this specific data frame which is included in the package:
```{r}
help(Guerry)
```

French cities and statistics about them

* A few categories: Region, Main_city
* A few numerical variables: e.g., Crime pers … Suicides
* A few rank variables: Donations, 

1) Select any numerical variable and plot a histogram

2) Choose variable "Literacy" and make a box plot per region and city size (MainCity)  

**TODO** what is meant here?  This seems to be done in two commands further below

hint: data1~xxx, groups data by the categories contained in the variable xxx

**TODO** split this into two boxplots as shown below

```{r}
ggplot(data1, aes(x=Region, y=Literacy)) + geom_boxplot() + facet_wrap(~MainCity)
```

1) Select any numerical variable and plot a histogram

```{r}	
hist(data1$Infants)
```

2) Choose numerical variable and make a box plot per region and city size (MainCity)  

**TODO** this seems to be what is mentioned above

```{r}
boxplot(data1$Literacy~data1$Region)
boxplot(data1$Literacy~data1$MainCity)
```

3) we see that the box in the small cities looks weird, we want to take a closer look 

3a) First we want to know how many variables are in the small, medium and large cities

```{r}
a <- table(data1$MainCity)
a
```

3b) Now we want to see the actual data points in the small cities only:
Subset command!

**TODO** which dataset is this?  Only focus on using with data1?

The subset( ) function is the easiest way to select variables and observations. In the following example, we select all rows that have a value of age greater than or equal to 20 or age less then 10. We keep the ID and Weight columns.

 using subset function 
```{r, eval=FALSE}
newdata <- subset(mydata, age >= 20 | age < 10, select=c(ID, Weight))
```

In the next example, we select all men over the age of 25 and we keep variables weight through income (weight, income and all columns between them).

using subset function (part 2)

**TODO** explain the logical operators - & |

**TODO** put in a note about how dplyr deals with NA.  Whatever happens, the NA are gone.  If you want the NA with dplyr - do 2 comparisons - numeric | is.na()


```{r, eval=FALSE}
newdata <- subset(mydata, sex=="m" & age > 25, select=weight:income)

newdata = mydata %>% filter(sex=="m" & age > 25) %>% select(weight,income)
```

3b) Now: apply to data1

Note that the `==` is a check to see if two values are equal to each other

```{r}
small_data <- subset(data1, MainCity ==  "1:Sm", select = Literacy)
plot(small_data)

small_data <- data1 %>% filter(MainCity ==  "1:Sm") %>% select(Literacy)
plot(small_data)

```

4) Make a boxplot of crime vs city size

You see a large outlier in the small cities. This would disturb a test like ANOVA. remove the outlier

**TODO** the part with `!(MainCity == "1:Sm" & Crime_prop > 15000)` really needs to be explained

* `!` means
* `==` means
* `&` means
* then `(`...`)` means

```{r}
data2 <- subset(data1, !(MainCity == "1:Sm" & Crime_prop > 15000))
boxplot(data2$Crime_prop~data2$MainCity)

# dplyr method
data2 = data1 %>% filter(!(MainCity == "1:Sm" & Crime_prop > 15000))
boxplot(data2$Crime_prop~data2$MainCity)
```



5) select any row and column you want 

here you can make a submatrix of a larger matrix, etc. 
sub dataframe - depends on the data type

```{r}
b <- data1[1:3, 5:9]
c <- data1[c(1,5,9), 7]
```

pretend that you have a data frame named input1

(students just see an explanation - don't run this code)

```{r, eval=FALSE}
# can select a consecutive sequence, and also non-consecutive sequence (2 and 4)
input_s <- input1[1:10, c(2,4)]   # selects row 1:10 and column 2 and 4
input_s <- input1[, c("x", "y")]  # selects all rows, and the columns named "x" and "y"
```

`input_s` is also a data frame!


select individual vectors: 
```{r, eval=FALSE}
x <- input1$x
```
or
```{r, eval=FALSE}
x <- input1$x[1:10]  #just select the first 10 rows
```

make the whole data frame into a matrix
```{r, eval=FALSE}
input_m <- as.matrix(input1)
```

`length(input_m)` gives the number of all elements in the matrix

`input_m$x` does not work any more


6) Make a table of city size vs region

```{r}
tab = table(data1$MainCity, data1$Region)
tab
```


**TODO** if too much material, leave out the boxplots

# Dates and Times

Useful resources: 

* [Working with Time Series Data in R ](http://faculty.washington.edu/ezivot/econ424/Working%20with%20Time%20Series%20Data%20in%20R.pdf)
* [R cheat sheet](http://blog.yhat.com/static/pdf/R_date_cheat_sheet.pdf). Note the `Date` and `POSIXct` columns.  We don't use the `lubridate` library for this example.


## Integers to Dates
1) Dates, not involving times of the day, are natively stored on your computer as integer numbers with 1 Jan 1970  = 0 and 1 corresponding to 1 day. Due to this, you need to specify `origin="1970-01-01"` in the example below.  

e.g., The number 365 corresponds 1 Jan 1971

To tell R that a number is a date, not just a number you use the command.  
```{r}
as.Date(365, origin="1970-01-01")
```
 
## Strings to Dates
R can also convert strings to dates
```{r}
as.Date("1971-01-01")   # always use the order of year, month, day
```

## Vectors of Date Ranges
You can make vectors filled with series of dates by
```{r}
t = seq(from = as.Date("2000-11-30"), to = as.Date("2005-05-26"), by="1 day")
```

`by=` can be e.g, 1 month, 2 years, 5 days, etc...

Try to make a weekly time vector from 5 June 2005 to 20 August 2006

Otherwise you can treat time vectors as normal vectors 
(use them in plots, add, subtract, ...)

# Dates and Times

POSIXct does more or less the same as Date, but stores the time variable as numbers of seconds since midnight GMT 1970-01-01.  As a result, this allows us to store data which expresses the time on a specific date.

```{r}
t.str = "2013-12-19 10:17:07"    # default format
t.obj = as.POSIXct(t.str) 
t.obj
```

If you have any other format than default format e.g., if you need to read in data that are not in the default format, then you can give R the format the data are in:

```{r}
t.str1 = "19-12-2013 10:17:07"
t.obj1 = as.POSIXct(t.str1, format="%d-%m-%Y %H:%M:%S")
t.obj1
```

To get an overview of all the format types type `help(strptime)`

## Changing format of date

**TODO** need to explain the big table before here, point out %a, %d, %b, %Y, show what they mean, then show it in the example

You can change the format of the output date:
```{r}
t.obj1
format(t.obj1, "%a %d %b. %Y")
```

## Adding and subtracting dates
You can add and subtract POSIXt objects and perform logical operations on them. If you have a vector of POSIXt objects, you can use the `min()`, `max()` and `range()` functions. 

```{r}
t.str2 = "2013-12-19 18:20:07"
t.obj2 = as.POSIXct(t.str2)
```

Subtract two date times:
```{r}
t.obj1 - t.obj2
```

**TODO** add in extra exercises for subtracting & formatting dates based on above examples

## Exercise 1

Load in the data

Exercise: read in Pr_20May1.csv
it contains a time series of monthly temp. from Jan. 1946 to Dec. 2014
Make a vector with the dates corresponding to each data point

```{r, echo=FALSE}
pr = read.csv("/home/cbdavis/Desktop/svn/ChrisDavis/Education/DASM/ComputerPracticals/Pr_20May1.csv")
t = seq(from = as.Date("1946-01-01"), to = as.Date("2014-12-01"), by="1 month")
pr$t = t
library(ggplot2)
ggplot(pr, aes(x=t, y=x)) + geom_line()
```

**TODO** big break - handling real data - create new top level heading

Now we are starting to handle real data, here is an example.  All this goes over what has to be done

* dealing with NA
* dealing with strange/ unwieldy column names
* dealing with dates


1) Real data can have inconvenient column names

How to rename columns in a data set:
e.g. data set: input1


**TODO** put this where the student can download it - put on nestor, also for github

explanation here of how to rename columns

```{r, eval=FALSE}	
#rename column
colnames(input1)[1] <- "x" 	# gives the first column the name "x"
colnames(input1)[2] <- "y"		# gives the second column the name "y"

names(input1)[1] <- "x" 	# gives the first column the name "x"
names(input1)[2] <- "y"		# gives the second column the name "y"
```

## Exercise 2

**TODO** stuff = input1 in notes
Load the data set "Practical4.csv"from nestor and rename the column with the long weird name
See /home/cbdavis/Desktop/svn/ChrisDavis/Education/DASM/ComputerPracticals/Practical_2015_example_chris.pptx

Try to load the file yourselves

```{r, echo=FALSE}
input1 = read.csv("/home/cbdavis/Desktop/svn/ChrisDavis/Education/DASM/ComputerPracticals/Practical4.csv")
```




2) Real data can have missing values

Missing values in R are named NA
But in some data sets the missing values can have any name (e.g.NaN …)
Often they are also indicated by an unrealistic number (e.g., -999)

For R to handle the missing values, you have to rename them as NA, if the are not named like that, R does not recognize them
	
e.g. a data frame called input1 with -999 for missing values

Explain what this comment means
```{r, eval=FALSE}	
input1[input1 == -999] <-NA
```

What does this command do?

`x<-(input1 == -999)`  gives a vector/matrix of the same size as input 1

**TODO** in this case it's a logical matrix
This vector is logical (contains `TRUE`, `FALSE`, and `NA`)

If such a matrix is put into input1 it selects only the fields where x shows `TRUE`

Then it only the fields that are `-999` are replaced by `NA`
	
2) Real data can have missing values

Exercise 2:

before: run summary
```{r}
summary(input1)
```

```{r, echo=FALSE}
input1[input1 == -999] <-NA
```

```

try replacing the -999 in the data set by NA

If you do it correctly, you should see:
```{r}
summary(input1)
```

4) dates and times can be in any format
Then we deal with the dates and times

**TODO** include table

| Code | Description              | Example |
|------|--------------------------|---------|
| %a | Abbreviated weekday name | Mon |
| %A | Full weekday name | Monday |
| %b | Abbreviated month name | Jan |
| %B | Full month name | January |
| %c | Date and time. Locale-specific on output, "%a %b %e %H:%M:%S %Y" on input. | |
| %d | Day of the month as decimal number (01–31) | 01 |
| %H | Hours as decimal number (00–23) | 16 |
| %I | Hours as decimal number (01–12) | 08 |
| %j | Day of year as decimal number (001–366) | 234 | 
| %m | Month as decimal number (01–12) | 07 |
| %M | Minute as decimal number (00–59) | 12 | 
| %p | AM/PM indicator | AM |
| %S | Second as integer (00–59) | 35 | 
| %U | Week of the year as decimal number (00–53) using Sunday as the first day 1 of the week (and typically with the first Sunday of the year as day 1 of week 1). The US convention. | |
| %w | Weekday as decimal number (0–6, Sunday is 0). | 1 |
| %W | Week of the year as decimal number (00–53) using Monday as the first day of week (and typically with the first Monday of the year as day 1 of week 1). The UK convention. | | 
| %x | Date. Locale-specific on output, "%y/%m/%d" on input. | | 
| %X | Time. Locale-specific on output, "%H:%M:%S" on input. | |
| %y | Year without century (00–99) | 91 |
| %Y | Year with century | 1991 |
| %z | Signed offset in hours and minutes from UTC, so -0800 is 8 hours behind UTC | |
| %Z | Time zone abbreviation as a character string | PST |


Exercise 3: 

**TODO** use stuff/input1 data set

* Make time vector of the date in the data set you imported (the `date_start` column)
* make a new vector that formats the date, so that it just shows the month (hint: use the command: `format(date, format = " …" )` covered in the last practical

**TODO** put in the r code for showing the months & the solution

4) sometimes real data sets don't directly contain all the information you want

e.g., you have data covering a year and you are wondering if there is a difference between summer and winter, or between day and night; but you only have a vector with date and time

Make new category variables (e.g. for anova, box plots etc..)

e.g. `input1$y` varies between 0 and 5

```{r, eval=FALSE}
x1 <- c() 	# start with empty vector
x1[input1$y < 1] <- "low"
x1[(input1$y >=1) & (input1$y < 3)] <- "medium"
x1[input1$y>=3] <- "high"
```

`x1` is now a vector of length `input1$y` and consists of values `"low"`, `"medium"`, `"high"`

Exercise 4

Make a vector that correctly assigns the seasons to your data set ( use the meteorological definition of season e.g. winter is dec, jan, feb; spring is mar, apr, may .. 
Look up the logical operators you might need on the internet

**TODO** show what correct output should look like
  
5)combine new data with your data set, or combine several data sets

e.g. second data set input 2 with the same number of rows

**TODO** merge in the season vector with the data frame

```{r, eval=FALSE}
data_new <- cbind(input1, input2) 	#column bind
```

e.g., second data set with new values in the same columns 

e.g., add a new vector x to a data frame

**TODO** you can add vectors to data frames (show)

Exercise 5
add the vector of months and the vector of seasons to your data frome

