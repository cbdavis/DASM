---
title: "Practical 4"
author: "Chris Davis"
date: "September 26, 2016"
output: 
    html_document:
        toc: true
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
```

Notes:

If it helps, there is a version of an earlier computer practicum gave last year that helped with the used a data set, where you could make tables and also groups fro ANO. Also in the beginning they learned to plot functions, but this you can ignore 
also R code for making a table and a one-way ANOVA

Computer practicum:

Make sure to first load the `ggplot2` library:

```{r}
library(ggplot2)
```

# The test for equality in variance

## Reminder from lecture:

A test of s in two different populations with size  $n_1$, $n_2$ involves the following:

1) A confidence level 1-$\alpha$
2) Two independent, random samples of normal distributions
3) Null hypothesis, $H_0$: $s_1 \le s_2$, or $s_1 \ge s_2$, or $s_1 = s_2$
4) Alternative hypothesis, $H_a$: 
    + $s_1 \gt s_2$     (upper tail alternative)
    + $s_1 \lt s_2$     (lower tail alternative)
    + $s_1 \ne s_2$     (two tailed)
5) Test statistic: $F = \frac{{s_{1}}^2}{{s_{2}}^2}$


## Syntax in R:

```{r, eval=FALSE}
var.test(x, y, ratio = 1, 
         alternative = c("two.sided", "less", "greater"),
         conf.level = 0.95, ...)
```

## Example 

(from the lecture (show and explain the students))

Take 100 samples from two normal distributions with different mean, but the same variance.  Will the test recognize that we should not reject the null hypothesis?

```{r}
x <- rnorm(100, mean=0)  # if you don’t specify the variance it is set to 1 by default
y <- rnorm(100, mean=1)
```

F test to compare two variances
```{r}
var.test(x, y, ratio = 1, alternative = "two.sided", conf.level = 0.95)      
```

## Exercise on you own 
 a) Take 100 random samples from normal distributions with a different variance e.g., mean = 0, sd = 1 and sd = 1.2 
 
You should see:
```{r, echo=FALSE} 
x <- rnorm(100, mean=0, sd=1)  
y <- rnorm(100, mean=0, sd=1.2)
```
 
 … run the var.test again
 You should see:
```{r, echo=FALSE}
var.test(x, y, ratio = 1, alternative = "two.sided", conf.level = 0.95)
```
 b) try both above examples again with n = 10 

Different means, same variance
```{r, echo=FALSE}
x <- rnorm(10, mean=0)  # if you don’t specify the variance it is set to 1 by default
y <- rnorm(10, mean=1)
var.test(x, y, ratio = 1, alternative = "two.sided", conf.level = 0.95)
```

Same mean, different variance
```{r, echo=FALSE}
x <- rnorm(10, mean=0, sd=1)  # if you don’t specify the variance it is set to 1 by default
y <- rnorm(10, mean=0, sd=1.2)
var.test(x, y, ratio = 1, alternative = "two.sided", conf.level = 0.95)
```

# Chi-square test for tabular data

## Preliminaries constructing tables from categorical data 

### reminder about reading in data sets, getting an idea of the variables etc

```{r}
colnames(iris)
```

```{r}
summary(iris)
```

### extract variables with the $ command 
```{r}
iris$Sepal.Length
```


### syntax of the table command

*table uses the cross-classifying factors to build a contingency table of the counts at each combination of factor levels.*

```{r, eval=FALSE}
table(...,
      exclude = if (useNA == "no") c(NA, NaN),
      useNA = c("no", "ifany", "always"),
      dnn = list.names(...), deparse.level = 1)
```

**TODO** this needs to be simplified and clarified.  We just need an x and y, right?

Arguments:

* `...` - one or more objects which can be interpreted as factors (including character strings), or a list (or data frame) whose components can be so interpreted. (For as.table, arguments passed to specific methods; for as.data.frame, unused.)
* `exclude` - levels to remove for all factors in .... If set to NULL, it implies `useNA = "always"`. See ‘Details’ for its interpretation for non-factor arguments.

### construct a table from one or two variables 

Here we create a table from the `cyl` (number of cylinders) column of the `mtcars` data set:
```{r}
table(mtcars$cyl)
```

Reading across, we see that there are 11 cars with 4 cylinders, 7 with 6 cylinders, and 14 with 8 cylinders.

Next we create a table from the `cyl` and `gear` (number of forward gears) columns of the `mtcars` data set:

```{r}
table(mtcars$cyl, mtcars$gear)
```

With the `table` function, the first value you enter (`mtcars$cyl`) will show up on the rows, and the second (`mtcars$gear`) will show up in the columns.  For example, from the table we can see that there are 12 cars with 8 cyclinders and 3 gears, while there are 0 cars with 4 gears and eight cylinders.


### Exercise:

Load in data on heart attack victims.  With R you can download a file directly from the Internet.  Note that `sep="\t"` means that the file is tab delimited
```{r}
df = read.csv("http://courses.statistics.com/Intro1/Lesson2/heartatk4R.txt", sep="\t")
```

Now construct a two way table from the categorical variables `SEX` and `DIED`.  You should see:

```{r, echo=FALSE}
table(df$SEX, df$DIED)
```

## Chi-square test for goodness of fit

### Reminder from the lecture

Hypothesis: n events that occur with probabilities $p_i$

Observations: counts for each event ($n_1$, $n_2$, …, $n_i$, …,$n_k$)

Test statistic:  

$$ \chi^{2} = \sum{}\frac{(observed - expected)^{2}}{expected} = \sum_{i=1}^{k} \frac{(n_i-E_i)^2}{E_i}$$

with $E_i = n * p_i$

### Syntax of chi-square test for goodness of fit

For the chi-square test for goodness of fit, you only need to have two arguments specified:

```{r, eval=FALSE}
chisq.test(x, p) 
```

Arguments:

* `x`	- a numeric vector or matrix. `x` and `y` can also both be factors.
* `p` - a vector of probabilities of the same length of `x`. An error is given if any entry of `p` is negative.

p should be a vector of length x. If it is not specified the program automatically assumes equal probabilities. 

### Example 
the dice from the lecture 6

You roll a die 100 times, and these are the number of counts associated with each value of the die that was observed.

```{r}
die = c(1,2,3,4,5,6)
count = c(11,16,25,13,21,14)
```

#### For a fair dice: what would be the expected probabilities?

We would expect $p_i = \frac{1}{6}$ for each value of $i$

For the counts at each die value, we would expect:
```{r}
exp = rep(1/6, 6) * 100
exp
```

#### Question: Is the die fair at 95% confidence level?

* $H_0$: the probability of throwing each number is equal = $\frac{1}{6}$ 
    * i.e. $p_i = \frac{1}{6}$ for all $i$ 
* $H_a$: at least one number comes at a different frequency 
    * i.e. $p_i \neq \frac{1}{6}$ for at least one $i$

**TODO** only show how to use `chisq.test`.  Can remove things before that.


Use the `chisq.test` function to see the same results:
```{r}
chisq.test(count, p=rep(1/6, 6))
```

The peak should mean that we have the highest probability of getting a $\chi^2$ value of 3 with a fair die.  

```{r, echo=FALSE}
# manuals for adding math symbols to plots is at:
# https://stat.ethz.ch/R-manual/R-patched/library/grDevices/html/plotmath.html
# http://vis.supstat.com/2013/04/mathematical-annotation-in-r/
library(ggplot2)
chi_squared = chisq.test(count, p=rep(1/6, 6))
x = seq(0,20,0.01)
y = dchisq(x, df=5)
df = data.frame(x=x, y=y)
ggplot(df, aes(x,y)) + geom_line() + 
  geom_area(data = subset(df, x > qchisq(0.95, 5)), 
            aes(x=x, y=y), fill="red", alpha=0.5) + 
  geom_vline(xintercept = chi_squared$statistic, linetype="dashed") + 
  annotate("label", x = chi_squared$statistic, y=0.1, label="list(chi^2,'calculated')", parse=TRUE) + 
  geom_vline(xintercept = qchisq(0.95, 5), linetype="dashed") + 
  annotate("label", x = qchisq(0.95, 5), y=0.05, label="chi[list(0.95,5)]^{2}", parse=TRUE) + 
  ylab("probability") + xlab(expression(chi^{2}))

```

### Try on your own:
the example of the murder cases from the lecture 

| Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | 
|-|-|-|-|-|-|-|-|
| 53| 42| 51| 45| 36| 37| 65 | 

Are the murders equally distributed through the week or not at a confidence level of 0.95?

What are the test hypotheses, df, and p-value?

If you do things correctly (and set `correct=FALSE`), you should see an output of:
```{r, echo=FALSE}
murders <- c(53, 42, 51, 45, 36, 37, 65)
cst = chisq.test(murders,p=rep(1/7, 7), correct=FALSE)
print(cst)

cst = chisq.test(murders,p=rep(1/7, 7))
```

## Chi-square test of independence

### Review from lecture 6

**TODO** include page numbers

2-way table:

**TODO** insert table here

Hypothesis test:

* $\alpha$ = 0.05
* $H_0$ : the outcomes are independent
* $H_a$ : outcomes are dependent

Test statistic:

$$\chi^2 = \sum_{i=1}^{k}\sum_{j=1}^{l} \frac{(n_{ij}-n_{i\cdot}*n_{\cdot j}/n)^2}{n_{i\cdot}*n_{\cdot j}/n} $$


### Syntax

x … two way table
```{r, eval=FALSE}
chisq.test(x) 
```
… again I like to keep it simple

### Example from the lecture (buckled, unbuckled)

**TODO** add explanatory text

```{r}
seatbelt = rbind(c(56, 8), c(2, 16))
colnames(seatbelt) = c("child_buckled", "child_unbuckled")
rownames(seatbelt) = c("parent_buckled", "parent_unbuckled")

seatbelt
```

Need to create expected matrix

* $\alpha=0.05$
* $H_0$: the variables are independent
* $H_a$: the variables are dependent

want to find $p(A \cap B) = p(A)p(B)$


```{r}
parent = rowSums(seatbelt)
child = colSums(seatbelt)

parent
child
```

For the sake of convenience, we want to have the `rowSums` and `colSums` values available in such a way that we can access the values with the `$` operator like `parent$parent_buckled`.  To do this, we can convert the results to a list using `as.list`.  As you noticed in the previous results, we already have the names associated with the values (i.e. when printing the value of the `parent` variable, you see the names `parent_buckled` and `parent_unbuckled`).  If we didn't see any names like this, then converting it to a list wouldn't be useful.  

```{r}
parent = as.list(rowSums(seatbelt))
child = as.list(colSums(seatbelt))

# total population size (all adults & children)
total = sum(seatbelt)

# Expected value for parent buckled, child buckled
# The n11, n12, etc correspond to the notation used in the lecture slides
EV_pb_cb = (parent$parent_buckled * child$child_buckled) / total      # n11
EV_pb_cu = (parent$parent_buckled * child$child_unbuckled) / total    # n12
EV_pu_cb = (parent$parent_unbuckled * child$child_buckled) / total    # n21
EV_pu_cu = (parent$parent_unbuckled * child$child_unbuckled) / total  # n22

# create a new matrix of the expected values
# rbind combines the rows together
seatbelt_EV = rbind(c(EV_pb_cb, EV_pb_cu), c(EV_pu_cb, EV_pu_cu))
# copy the row and column names from the seatbelt matrix
rownames(seatbelt_EV) = rownames(seatbelt)
colnames(seatbelt_EV) = colnames(seatbelt)
seatbelt_EV
```

The method above is ok if your table only contains a very few elements.  A more efficient way to calculate `seatbelt_EV`, especially if you are dealing with a large table, would be to directly use vector operations.  Here `t()` transposes the vector returned by the `colSums` function.  This results in us multiplying a 2x1 matrix with a 1x2 matrix.

Note the `%*%`, which specifies that we want to do matrix multiplication.  Simply using `*` would perform element-wise multiplication.  See [here](http://www.ats.ucla.edu/stat/r/library/matrix_alg.htm) for examples showing the difference.

```{r}
seatbelt_EV = (rowSums(seatbelt) %*% t(colSums(seatbelt)))/total
# add in the rownames, the column names are already present
rownames(seatbelt_EV) = rownames(seatbelt)
seatbelt_EV
```

We can now calculate $\chi^2$ using the matrices:
```{r}
sum(((seatbelt - seatbelt_EV)^2)/seatbelt_EV)
```

We can also do this directly via the `chisq.test` function.  Make sure to specify `correct=FALSE`, as by default the `chisq.test` function applies a correction if some counts in the table are low.  If you leave the value empty or specify `correct=TRUE` you'll get a slightly deviating value.

```{r}
chisq.test(seatbelt, correct=FALSE)
```

### Another example of two categorical variables, that they can try on their own 

(students get the table - page 556 of book), question 10.60

Age
Under 30 30–39 40–49 50 and Over Total
Promoted
Not promoted 9
41 29
41 32
48 10
40 80
170
Totals 50 70 80 50

create the above table in R

perform the chisq.test on the data above.

# One way Anova test

Here I want to use a different example from the lecture
 
## Reminder of the lecture:

Test if any of several means are different:

* Compare within goup variance (SSDw) to between group variance (SSDb)

If the means are all equal (i.e. the data are all from the same distribution) then the statistic: F =  SSDb/SSDw/(k-1)*(n-k) follows an F-distribution with (k-1), (n-1) degrees of freedom 

**TODO** CD lines below added from lecture slides
$${MS}_W = \frac{{SSD}_W}{(n-k)}$$
$${MS}_B = \frac{{SSD}_B}{(k-1)}$$
$$F = \frac{{MS}_B}{{MS}_W}$$

* If means are the same within the groups $F$ should be around 1 
* if they are different, then ${MS}_B >> {MS}_W$


## Syntax of the test

```{r, eval=FALSE}
oneway.test(formula, data, subset, na.action, var.equal = FALSE)
```

Explanation of formula:

* `formula`	- a formula of the form lhs ~ rhs where lhs gives the sample values and rhs the corresponding groups.
* `data` - an optional matrix or data frame (or similar: see `model.frame`) containing the variables in the formula formula. By default the variables are taken from environment(formula).
* `subset` - an optional vector specifying a subset of observations to be used.  Normally we don't use this option.
* `var.equal` - a logical variable indicating whether to treat the variances in the samples as equal. If `TRUE`, then a simple F test for the equality of means in a one-way analysis of variance is performed. If `FALSE`, an approximate method of Welch (1951) is used, which generalizes the commonly known 2-sample Welch test to the case of arbitrarily many samples.

Format of input variable: data frame with the columns and values:

**TODO**: fix width

| cal | month |
|-----|-------|
|2216 | may|
|1568 | may|
|2233 | may|
|1882 | may|
|2019 | may|
|2279 | sep|
|2075 | sep|

formula : `cal~month` (calories grouped by month)

## example

**NOTE** seems to be different slide numbers now.

walk through the example of the lecture and construct also the input table (commands in the lecture for now slides 36 - 42)


**TODO** add explanation for the code below - how we're stacking things up
```{r}
may <- c(2166,1568,2233,1882,2019) 
sep <- c(2279,2075,2131,2009,1793) 
dec <- c(2226,2154,2583,2010,2190) 

cal = c(may, sep, dec) 
# we do 5 repetitions because...
month = c(rep("may", 5), 
          rep("sep", 5), 
          rep("dec", 5)) 
data1 = data.frame(cal, month)

# perform the 1-way ANOVA test
oneway.test(cal~month, data1)
```

## Try on your own: 

zelazo data (ISwR package)

This is a list containing data on age at walking (in months) for four groups of infants:

* active - test group receiving active training; these children had their walking and placing reflexes trained during four three-minute sessions that took place every day from their second to their eighth week of life.
* passive - passive training group; these children received the same types of social and gross motor stimulation, but did not have their specific walking and placing reflexes trained.
* none - no training; these children had no special training, but were tested along with the children who underwent active or passive training.
* ctr.8w - eighth-week controls; these children had no training and were only tested at the age of 8 weeks.

$active
[1]  9.00  9.50  9.75 10.00 13.00  9.50

$passive
[1] 11.00 10.00 10.00 11.75 10.50 15.00

$none
[1] 11.50 12.00  9.00 11.50 13.25 13.00

$ctr.8w
[1] 13.25 11.50 12.00 13.50 11.50

Using what you learned above, first put the data into a format that can be used with the one way test, and conduct the test.  Create a box plot or a normal probability plot (`qqnorm` and `qqline` from the previous practical) to see if the data are roughly normally distributed.

-----

dataset - US generator data, group by state, columns per fuel type mentioning generation, efficiency for fossil plants
